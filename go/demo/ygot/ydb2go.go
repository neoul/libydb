package main // import "github.com/neoul/libydb/go/demo/ygot"

import (
	"fmt"
	"os"
	"reflect"

	ref "github.com/neoul/gostudy/datablock/reflection"
	"github.com/neoul/libydb/go/demo/ygot/model/schema"
	"github.com/neoul/libydb/go/ydb"
	"github.com/op/go-logging"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ytypes"
)

// Generate rule to create the example structs:
//go:generate go run ../../../../../../github.com/openconfig/ygot/generator/generator.go -path=yang -output_file=model/schema/example.go -package_name=schema -generate_fakeroot -fakeroot_name=example model/yang/example.yang

var (
	// Schema is schema information generated by ygot
	Schema *ytypes.Schema
	// Entries is yang.Entry list rearranged by name
	Entries map[string][]*yang.Entry

	ylog *logging.Logger
)

func init() {
	ylog = ydb.InitLog("ydb", os.Stderr)
	schema, err := schema.Schema()
	if err != nil {
		ylog.Panicf("%s\n", err)
	}
	Schema = schema
	Entries = make(map[string][]*yang.Entry)
	for _, branch := range schema.SchemaTree {
		entries, _ := Entries[branch.Name]
		entries = append(entries, branch)
		for _, leaf := range branch.Dir {
			entries = append(entries, leaf)
		}
		Entries[branch.Name] = entries
		// if branch.Annotation["schemapath"] == "/" {
		// 	SchemaRoot = branch
		// }
	}
	// for _, i := range Entries {
	// 	for _, j := range i {
	// 		ylog.Debug(j)
	// 	}
	// }
}

func find(entry *yang.Entry, keys ...string) *yang.Entry {
	var found *yang.Entry
	if entry == nil {
		return nil
	}
	if len(keys) > 1 {
		found = entry.Dir[keys[0]]
		if found == nil {
			return nil
		}
		found = find(found, keys[1:]...)
	} else {
		found = entry.Dir[keys[0]]
	}
	return found
}

// Updater interface to build go struct
type Updater interface {
	Create(keys []string, key string, tag string, value string) error
}

// DefaultStruct - Default Go Struct for YDB unmarshal
type DefaultStruct map[string]interface{}

// Create - constructs the DefaultStruct structure
// func (defStruct DefaultStruct) Create(keys []string, key string, tag string, value string) error {
// 	ds := defStruct
// 	for _, k := range keys {
// 		ds = ds[k].(DefaultStruct)
// 	}
// 	if value == "" {
// 		(ds)[key] = DefaultStruct{}
// 	} else {
// 		(ds)[key] = value
// 	}
// 	return nil
// }

// Create - constructs the DefaultStruct structure
func (defStruct *DefaultStruct) Create(keys []string, key string, tag string, value string) error {
	ds := *defStruct
	for _, k := range keys {
		ds = ds[k].(DefaultStruct)
	}
	if value == "" {
		(ds)[key] = DefaultStruct{}
	} else {
		(ds)[key] = value
	}
	return nil
}

// GoStruct - Go Struct for YDB unmarshal
type GoStruct schema.Example

// Create - constructs the DefaultStruct structure
func (example *GoStruct) Create(keys []string, key string, tag string, value string) error {
	var cv reflect.Value
	ylog.Debugf("Create %v %v %v %v", keys, key, tag, value)
	dv := reflect.ValueOf(example)
	cv = dv
	if len(keys) > 0 {
		cv = ref.FindValue(dv, keys...)
		if !cv.IsValid() {
			return nil
		}
	}
	if cv.IsNil() {
		fmt.Println("cv is nil, dv.CanSet()", dv.CanSet())
		// if dv.CanSet() {
		cv = ref.NewValue(cv.Type())
		fmt.Println("cv: create", cv, cv.Type())
		dv.Set(cv)
		// }
	}
	ylog.Debugf("cv:: %v", cv)
	ref.SetValue(cv, key, value)
	return nil
}

func getUpdater(v reflect.Value, keys []string) (Updater, []string) {
	var updater Updater = nil
	var newkey []string = keys
	if v.Type().NumMethod() > 0 && v.CanInterface() {
		if u, ok := v.Interface().(Updater); ok {
			updater = u
		}
	}

	if len(keys) > 0 {
		fv := ref.FindValue(v, keys...)
		if !fv.IsValid() {
			return updater, newkey
		}
		v = fv
		if v.Type().NumMethod() > 0 && v.CanInterface() {
			if u, ok := v.Interface().(Updater); ok {
				updater = u
				newkey = []string{}
			}
		}
	}
	return updater, newkey
	// v0 := v
	// haveAddr := false

	// // If v is a named type and is addressable,
	// // start with its address, so that if the type has pointer methods,
	// // we find them.
	// if v.Kind() != reflect.Ptr && v.Type().Name() != "" && v.CanAddr() {
	// 	haveAddr = true
	// 	v = v.Addr()
	// }
	// for {
	// 	// Load value from interface, but only if the result will be
	// 	// usefully addressable.
	// 	if v.Kind() == reflect.Interface && !v.IsNil() {
	// 		e := v.Elem()
	// 		if e.Kind() == reflect.Ptr && !e.IsNil() && e.Elem().Kind() == reflect.Ptr {
	// 			haveAddr = false
	// 			v = e
	// 			continue
	// 		}
	// 	}

	// 	if v.Kind() != reflect.Ptr {
	// 		ylog.Debug("non-ptr loop break")
	// 		break
	// 	}

	// 	// Prevent infinite loop if v is an interface pointing to its own address:
	// 	//     var v interface{}
	// 	//     v = &v
	// 	if v.Elem().Kind() == reflect.Interface && v.Elem().Elem() == v {
	// 		v = v.Elem()
	// 		ylog.Debug("infinite loop break")
	// 		break
	// 	}
	// 	if v.IsNil() {
	// 		v.Set(reflect.New(v.Type().Elem()))
	// 	}
	// 	if v.Type().NumMethod() > 0 && v.CanInterface() {
	// 		if u, ok := v.Interface().(Updater); ok {
	// 			return u, []string{}
	// 		}
	// 	}

	// 	if haveAddr {
	// 		v = v0 // restore original value after round-trip Value.Addr().Elem()
	// 		haveAddr = false
	// 	} else {
	// 		v = v.Elem()
	// 	}
	// }
	// return updater, newkey
}

// Create - constructs the DefaultStruct structure
func create(v reflect.Value, keys []string, key string, tag string, value string) error {
	var pkey string
	var cv, pv reflect.Value
	ylog.Debugf("Create %v %v %v %v", keys, key, tag, value)
	pv = v
	cv = v
	if len(keys) > 0 {
		pv, cv, pkey = ref.FindValueWithParent(pv, cv, keys...)
		if !cv.IsValid() {
			return nil
		}
		if ref.IsValueInterface(cv) {
			if tag == "!!seq" {
				if cv.Elem().Type().Kind() != reflect.Slice {
					err := ref.SetChildValue(pv, pkey, reflect.ValueOf([]interface{}{}))
					if err != nil {
						return err
					}
				}
			} else {
				if cv.Elem().Type().Kind() != reflect.Map {
					err := ref.SetChildValue(pv, pkey, reflect.ValueOf(map[string]interface{}{}))
					if err != nil {
						return err
					}
				}
			}
			pv, cv, pkey = ref.FindValueWithParent(v, v, keys...)
			if !cv.IsValid() {
				return nil
			}
		}
	}
	ref.SetValue(cv, key, value)
	return nil
}

func update(keys []string, node *ydb.YNode, updater Updater) {
	childnodes := node.GetChildren()
	for i, childnode := range childnodes {
		ylog.Debugf("%d:%d. %s", len(keys), i, childnode.GetKey())
		updater.Create(keys, childnode.GetKey(), childnode.GetTag(), childnode.GetValue())
		update(append(keys, childnode.GetKey()), childnode, updater)
	}
}

func Ydb2Go(node *ydb.YNode, updater Updater) {
	update([]string{}, node, updater)
	ylog.Debug(updater)
}

func unmarshal(keys []string, node *ydb.YNode, v reflect.Value) {
	updater, keys := getUpdater(v, keys)
	if updater != nil {
		childnodes := node.GetChildren()
		for i, childnode := range childnodes {
			ylog.Debugf("%d:%d. %s %s", len(keys), i, keys, childnode.GetKey())
			updater.Create(keys, childnode.GetKey(), childnode.GetTag(), childnode.GetValue())
			unmarshal(append(keys, childnode.GetKey()), childnode, reflect.ValueOf(updater))
		}
	} else {
		childnodes := node.GetChildren()
		for i, childnode := range childnodes {
			ylog.Debugf("%d:%d. %s", len(keys), i, childnode.GetKey())
			create(v, keys, childnode.GetKey(), childnode.GetTag(), childnode.GetValue())
			unmarshal(append(keys, childnode.GetKey()), childnode, v)
		}
	}
}

func Ydb2Go2(node *ydb.YNode, value interface{}) {
	v := reflect.ValueOf(value)
	unmarshal([]string{}, node, v)
}

func main() {
	example := Schema.Root
	ylog.Debug(example)

	db, close := ydb.Open("mydb")
	defer close()
	// ydb.SetLog(ydb.LogDebug)

	r, err := os.Open("model/data/example.yaml")
	defer r.Close()
	if err != nil {
		ylog.Fatal(err)
	}
	dec := db.NewDecoder(r)
	dec.Decode()
	var user interface{}
	user, err = db.Convert(ydb.RetrieveAll())
	ylog.Debug(user)
	// node := db.Retrieve(ydb.RetrieveAll())
	// ds := map[string]interface{}{}
	// Ydb2Go2(node, &ds)
	// ylog.Debug(ds)
	// ds := DefaultStruct{}
	// Ydb2Go2(node, &ds)
	// ylog.Debug(ds)
	// gs := GoStruct{Country: map[string]*schema.Network_Country{}, Operator: map[uint32]*schema.Network_Operator{}}
	// gs := GoStruct{}
	// gs.Country = map[string]*schema.Network_Country{}
	// gs.Operator = map[uint32]*schema.Network_Operator{}
	// gs := GoStruct{}
	// Ydb2Go2(node, &gs)
	// ylog.Debug(gs)
	// ylog.Debug(*gs.Country["United Kingdom"].Name, *gs.Country["United Kingdom"].CountryCode, *gs.Country["United Kingdom"].DialCode)
	// gs := schema.Device{}
	// Ydb2Go2(node, &gs)
	// ylog.Debug(gs)
	// ylog.Debug(*gs.Country["United Kingdom"].Name, *gs.Country["United Kingdom"].CountryCode, *gs.Country["United Kingdom"].DialCode)
}
